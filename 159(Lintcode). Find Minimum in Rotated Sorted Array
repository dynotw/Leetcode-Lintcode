159. Find Minimum in Rotated Sorted Array
Suppose a sorted array in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Find the minimum element.

Example
Example 1:

Input：[4, 5, 6, 7, 0, 1, 2]
Output：0
Explanation：
The minimum value in an array is 0.
Example 2:

Input：[2,1]
Output：1
Explanation：
The minimum value in an array is 1.
Notice
You can assume no duplicate exists in the array.






public class Solution {
    /**
     * @param nums: a rotated sorted array
     * @return: the minimum number in the array
     */
    public int findMin(int[] nums) {
        // write your code here
        
        // this problem is to find the minimum
        // this array is combined by two sorted array
        // use Binary Search
        
        // eliminate the special condition
        if (nums == null ||nums.length == 0){
            return -1;
        }
        
        //set the two pointer
        int left = 0;
        int right = nums.length - 1;
        
        // there is no target in this problem
        // we only need to compare mid and right, always remember the two indiviual array also are sorted, and the mid is nearly center
        // the number before or after mid, is quite similar (how many numbers will be ascended)
        while (left+1 < right){
            int mid = left +(right - left)/2;
            
            if (nums[mid] == nums[right]){
                // this place use left = mid, also is okay
                right = mid;
            }
            
            // 如果mid位置上的数字小于等于最右端的数字时，区间向左移动
            else if (nums[mid] < nums[right]){
                right = mid;
            }
            
            else if (nums[mid] > nums[right]){
                left = mid;
            }
        }
        
        // get the minimum between left and right
        return Math.min(nums[left],nums[right]);
    }
}
